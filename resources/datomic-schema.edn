[{:db/id #db/id [:db.part/db]
  :db/ident :onyx/log
  :db.install/_partition :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :peer/status
  :db/valueType :db.type/keyword
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}
 
 {:db/id #db/id [:db.part/db]
  :db/ident :peer/task
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/add-peer
  :db/fn #db/fn {:lang "clojure"
                 :params [db eid status peer-node]
                 :code (if-not (ffirst (q '[:find ?peer :in $ ?node :where
                                            [?peer :node/peer ?node]]
                                          db peer-node))
                         [[:db/add eid :peer/status status]
                          [:db/add eid :node/peer peer-node]]
                         (throw (ex-info "Duplicate peer" {})))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/remove-peer
  :db/fn #db/fn {:lang "clojure"
                 :params [db peer-node]
                 :code (let [query '[:find ?e :in $ ?place :where [?e :node/peer ?place]]
                             entity-id (ffirst (q query db peer-node))]
                         (if entity-id
                           [[:db.fn/retractEntity entity-id]]
                           (throw (ex-info "Tried to remove non-existent peer" {}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/ack-task
  :db/fn #db/fn {:lang "clojure"
                 :params [db ack-node]
                 :code (let [query '[:find ?peer :in $ ?ack-node :where
                                     [?peer :node/ack ?ack-node]
                                     [?peer :peer/status :acking]
                                     [?peer :peer/task ?task]
                                     [?task :task/complete? false]]
                             peer-id (ffirst (d/q query db ack-place))]
                         (if peer-id
                           [[:db/add peer-id :peer/status :active]]
                           (throw (ex-info "Error for peer trying to ack" {}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/offer-task
  :db/fn #db/fn {:lang "clojure"
                 :params [db task peer-place nodes]
                 :code (let [peer-query '[:find ?p :in $ ?place ?task :where
                                          [?p :node/peer ?place]
                                          [?p :peer/status :idle]
                                          [?task :task/complete? false]]
                             task-query '[:find ?peer :in $ ?task :where
                                          [?p :peer/task ?task]]
                             peer-result (d/q peer-query db peer-place task)
                             task-result (q/q task-query db task)
                             peer-datom (ffirst peer-result)
                             task-datom (ffiirst task-result) ]
                         (if (and peer-datom (not task-datom))
                           [{:db/id peer-datom
                             :peer/status :acking
                             :peer/task (:db/id task)
                             :node/payload (:payload nodes)
                             :node/ack (:ack nodes)
                             :node/status (:status nodes)
                             :node/completion (:completion nodes)}]
                           (throw (ex-info "Error trying to offer to peer" {}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/complete-task
  :db/fn #db/fn {:lang "clojure"
                 :params [db complete-place]
                 :code (let [query '[:find ?peer ?task :in $ ?complete-node :where
                                     [?peer :peer/status :active]
                                     [?peer :peer/task ?task]
                                     [?peer :node/completion ?complete-node]
                                     [?task :task/complete? false]]
                             result (d/q query db complete-place)
                             peer (ffirst result)
                             task (second (first result))
                             tx [{:db/id task
                                  :task/complete? true}
                                 {:db/id peer
                                  :peer/status :idle}
                                 [:db/retract peer :peer/task]
                                 [:db/retract peer :node/payload]
                                 [:db/retract peer :node/ack]
                                 [:db/retract peer :node/status]
                                 [:db/retract peer :node/completion]]]
                         (if (and peer task)
                           tx
                           (throw (ex-info "Error for peer trying to complete task" {}))))}}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/id
  :db/valueType :db.type/uuid
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/catalog
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/workflow
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/task
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/many
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/name
  :db/valueType :db.type/keyword
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/phase
  :db/valueType :db.type/long
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/complete?
  :db/valueType :db.type/boolean
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/ingress-queues
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/many
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/egress-queues
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/many
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/peer
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/payload
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/ack
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/status
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/completion
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}]

