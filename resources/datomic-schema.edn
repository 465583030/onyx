[{:db/id #db/id [:db.part/db]
  :db/ident :onyx/log
  :db.install/_partition :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :peer/status
  :db/valueType :db.type/keyword
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}
 
 {:db/id #db/id [:db.part/db]
  :db/ident :peer/task
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/add-peer
  :db/fn #db/fn {:lang "clojure"
                 :params [db eid status peer-node]
                 :code (if-not (ffirst (q '[:find ?peer :in $ ?node :where
                                            [?peer :node/peer ?node]]
                                          db peer-node))
                         [[:db/add eid :peer/status status]
                          [:db/add eid :node/peer peer-node]]
                         (throw (ex-info "Duplicate peer" {})))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/remove-peer
  :db/fn #db/fn {:lang "clojure"
                 :params [db peer-node]
                 :code (let [query '[:find ?e :in $ ?place :where [?e :node/peer ?place]]
                             entity-id (ffirst (q query db peer-node))]
                         (if entity-id
                           [[:db.fn/retractEntity entity-id]]
                           (throw (ex-info "Tried to remove non-existent peer" {}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/ack-task
  :db/fn #db/fn {:lang "clojure"
                 :params [db ack-node]
                 :code (let [query '[:find ?peer :in $ ?ack-node :where
                                     [?peer :node/ack ?ack-node]
                                     [?peer :peer/status :acking]
                                     [?peer :peer/task ?task]
                                     [?task :task/complete? false]]
                             peer-id (ffirst (q query db ack-node))]
                         (if peer-id
                           [[:db/add peer-id :peer/status :active]]
                           (throw (ex-info "Error for peer trying to ack"
                                           {:ack-node ack-node :peer-id peer-id}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/offer-task
  :db/fn #db/fn {:lang "clojure"
                 :params [db task consumption peer-place nodes]
                 :code (let [peer-query '[:find ?p :in $ ?place ?task :where
                                          [?p :node/peer ?place]
                                          [?p :peer/status :idle]
                                          [?task :task/complete? false]]
                             task-query '[:find ?peer :in $ ?task :where
                                          [?peer :peer/task ?task]]
                             peer-result (q peer-query db peer-place task)
                             task-result (q task-query db task)
                             peer-datom (ffirst peer-result)
                             task-datom (ffirst task-result)]
                         (if (or (and (= consumption :sequential)
                                      (and peer-datom (not task-datom)))
                                 (and (= consumption :concurrent)
                                      peer-datom))
                           [{:db/id peer-datom
                             :peer/status :acking
                             :peer/task task
                             :node/payload (:payload nodes)
                             :node/ack (:ack nodes)
                             :node/status (:status nodes)
                             :node/completion (:completion nodes)}]
                           (throw (ex-info "Error trying to offer to peer"
                                           {:task task :consumption consumption
                                            :peer peer-place :nodes nodes :peer-datom peer-datom}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/revoke-offer
  :db/fn #db/fn {:lang "clojure"
                 :params [db ack-place]
                 :code (let [query '[:find ?peer :in $ ?node :where
                                     [?peer :node/ack ?node]
                                     [?peer :peer/status :acking]]
                             peer-entity (first (last (q query db ack-place)))]
                         (if peer-entity
                           [[:db.fn/retractEntity peer-entity]]
                           (throw (ex-info "Error revoking offer from peer"
                                           {:peer-entity peer-entity :ack ack-place}))))}}

 {:db/id #db/id [:db.part/user]
  :db/ident :onyx.fn/complete-task
  :db/fn #db/fn {:lang "clojure"
                 :params [db complete-place]
                 :code (let [query '[:find ?peer ?task :in $ ?complete-node :where
                                     [?peer :peer/status :active]
                                     [?peer :peer/task ?task]
                                     [?peer :node/completion ?complete-node]
                                     [?task :task/complete? false]]
                             node-query '[:find ?payload ?ack ?status ?completion :in $ ?peer :where
                                          [?peer :node/payload ?payload]
                                          [?peer :node/ack ?ack]
                                          [?peer :node/status ?status]
                                          [?peer :node/completion ?completion]]
                             result (q query db complete-place)
                             peer (ffirst result)
                             task (second (first result))
                             [payload ack status completion] (first (q node-query db peer))
                             peer-query '[:find (count ?peer) :in $ ?task :where
                                          [?peer :peer/task ?task]
                                          [?peer :peer/status :active]]
                             n-peers (ffirst (q peer-query db task))]
                         (if (and peer task)
                           (if (= n-peers 1)
                             [{:db/id task
                               :task/complete? true}
                              {:db/id peer
                               :peer/status :idle}
                              [:db/retract peer :peer/task task]
                              [:db/retract peer :node/payload payload]
                              [:db/retract peer :node/ack ack]
                              [:db/retract peer :node/status status]
                              [:db/retract peer :node/completion completion]]
                             [{:db/id task
                               :task/complete? false}
                              {:db/id peer
                               :peer/status :idle}
                              [:db/retract peer :peer/task task]
                              [:db/retract peer :node/payload payload]
                              [:db/retract peer :node/ack ack]
                              [:db/retract peer :node/status status]
                              [:db/retract peer :node/completion completion]])
                           (throw (ex-info "Error for peer trying to complete task" {}))))}}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/id
  :db/valueType :db.type/uuid
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/catalog
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/workflow
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :job/task
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/many
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/name
  :db/valueType :db.type/keyword
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/phase
  :db/valueType :db.type/long
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/consumption
  :db/valueType :db.type/keyword
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/complete?
  :db/valueType :db.type/boolean
  :db/cardinality :db.cardinality/one
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/ingress-queues
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/many
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :task/egress-queues
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/many
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/peer
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/payload
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/ack
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/status
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}

 {:db/id #db/id [:db.part/db]
  :db/ident :node/completion
  :db/valueType :db.type/string
  :db/cardinality :db.cardinality/one
  :db/unique :db.unique/value
  :db.install/_attribute :db.part/db}]

